<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>Main Page</title>
    <link href="dox.css" rel="stylesheet" type="text/css">
  </head>
<body bgcolor="#cfcfcf">

<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="object_system">Objects </a></h1><p>
Simulavr uses a simple object oriented system for handling the data structure creation and destruction. Since simulavr is written in C, a class system must be manually implemented and the basis for this class system is the AvrClass structure. All higher level structures are ultimately based on the AvrClass structure.<p>
How the AvrClass structure is defined is not as import as how it is used as a base or parent class structure. A concrete example of simulavr's object system will be discussed (see <a class="el" href="object_system.html#example_derived_class">Derived Class Example</a>), but before jumping into the example, the AvrClass method functions will be introduced.<h2><a class="anchor" name="avrclass">
AvrClass Methods</a></h2>
The following functions provide the user interfaces to the AvrClass structure.<p>
<ul>
<li><a class="el" href="avrclass_8c.html#d07c51bd8c81db78fab8d240fd698024" title="This function should never be used.">class_new()</a></li><li><a class="el" href="avrclass_8c.html#ffeb66dd49a62ad1b7606cde0e3b039e" title="Initializes the AvrClass data structure.">class_construct()</a></li><li><a class="el" href="avrclass_8c.html#86e290a528dd1ed0bf5057056b5731e5" title="Releases resources allocated by class&#39;s &lt;klass&gt;_new() function.">class_destroy()</a></li><li><a class="el" href="avrclass_8c.html#82d397ff00a7f1c1447832dbff1856e1" title="Overload the default destroy method.">class_overload_destroy()</a></li><li><a class="el" href="avrclass_8c.html#ff0f5b14bf2740f208041d515f3ba93f" title="Increments the reference count for the klass object.">class_ref()</a></li><li><a class="el" href="avrclass_8c.html#0e597261f2fe0c7c5a56de97ecc38693" title="Decrements the reference count for the klass object.">class_unref()</a></li></ul>
<p>
All classes must provide their own creation function, &lt;klass&gt;_new(). The purpose of the creation function is to:<p>
<ul>
<li>Allocate memory for the class's data structure.</li><li>Call <a class="el" href="avrclass_8c.html#82d397ff00a7f1c1447832dbff1856e1" title="Overload the default destroy method.">class_overload_destroy()</a> to install the class's own destroy method.</li><li>Call the class's constructor method to fill in the data structure information.</li></ul>
<h2><a class="anchor" name="example_derived_class">
Derived Class Example</a></h2>
<p>
Simulavr's inheritance mechanism is a little more complicated than that of C++, but is still relatively easy to use once it is understood. An example should make it clear how the system works.<p>
First we need to create some objects. Assume that we need to add two new objects to simulavr, <code>foo</code> and <code>bar</code>. To keep things simple, they are both integers. Another requirement is that any time we need to access a <code>foo</code>, we'll also need to access a <code>bar</code>, but sometimes we only need a <code>bar</code> without a <code>foo</code>. Thus, we will have a class hierarchy <code>FooClass-&gt;BarClass-&gt;AvrClass</code>, or <code>FooClass</code> derives from <code>BarClass</code> which derives from <code>AvrClass</code>. To achieve this, we create the following two data structures:<p>
    <div class="fragment"><pre class="fragment"><span class="comment">// Define BarClass with AvrClass as parent </span>

<span class="keyword">typedef</span> <span class="keyword">struct </span>_BarClass BarClass;
<span class="keyword">struct </span>_BarClass {
    AvrClass parent;
    <span class="keywordtype">int</span>      bar;
};

<span class="comment">// Define FooClass with BarClass as parent </span>

<span class="keyword">typedef</span> <span class="keyword">struct </span>_FooClass FooClass;
<span class="keyword">struct </span>_FooClass {
    BarClass parent;
    <span class="keywordtype">int</span>      foo;
};
</pre></div><p>
Notice that in both struct definitions, the parent element is not a pointer. When you allocate memory for a <code>BarClass</code>, you automatically allocate memory for an <code>AvrClass</code> at the same time. It's important that the parent is always the first element of any derived class structure.<p>
The trick here is that once we have a class object, we can get at any object in it's class hierarchy with a simple type-cast.<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> func( <span class="keywordtype">void</span> )
{
    <span class="keywordtype">int</span> num;
    FooClass *Foo = foo_new( 12, 21 );

    <span class="comment">// get foo from FooClass </span>
    num = Foo-&gt;foo;

    <span class="comment">// get bar from BarClass </span>
    num = ((BarClass *)Foo)-&gt;bar;

    <a class="code" href="avrclass_8c.html#0e597261f2fe0c7c5a56de97ecc38693" title="Decrements the reference count for the klass object.">class_unref</a>( (AvrClass *)Foo );
}
</pre></div><p>
Although the example above works, it assumes that the programmer knows what the <code>FooClass</code> and <code>BarClass</code> structures look like. The programmer has broken the encapsulation of both <code>FooClass</code> and <code>BarClass</code> objects. To solve this problem, we need to write method functions for both classes.<p>
Here's the methods for <code>BarClass:</code> <p>
 <div class="fragment"><pre class="fragment"><span class="comment">// BarClass allocator </span>
BarClass *bar_new( <span class="keywordtype">int</span> bar )
{
    BarClass *bc;

    bc = <a class="code" href="avrmalloc_8c.html#a543f348351cdcaebdd8947d1a591578" title="Macro for allocating memory.">avr_new</a>( BarClass, 1 );
    bar_construct( bc, bar );
    <a class="code" href="avrclass_8c.html#82d397ff00a7f1c1447832dbff1856e1" title="Overload the default destroy method.">class_overload_destroy</a>( (AvrClass *)bc, bar_destroy );

    <span class="keywordflow">return</span> bc;
}

<span class="comment">// BarClass constructor </span>
<span class="keywordtype">void</span> bar_construct( BarClass *bc, <span class="keywordtype">int</span> bar )
{
    <a class="code" href="avrclass_8c.html#ffeb66dd49a62ad1b7606cde0e3b039e" title="Initializes the AvrClass data structure.">class_construct</a>( (AvrClass *)bc );
    bc-&gt;bar = bar;
}

<span class="comment">// BarClass destructor </span>
<span class="keywordtype">void</span> bar_destroy( <span class="keywordtype">void</span> *bc )
{
    <span class="keywordflow">if</span> (bc == NULL)
        <span class="keywordflow">return</span>;

    <a class="code" href="avrclass_8c.html#86e290a528dd1ed0bf5057056b5731e5" title="Releases resources allocated by class&amp;#39;s &amp;lt;klass&amp;gt;_new() function.">class_destroy</a>( bc );
}

<span class="comment">// BarClass public data access methods </span>
<span class="keywordtype">int</span>  bar_get_bar( BarClass *bc )          { <span class="keywordflow">return</span> bc-&gt;bar; }
<span class="keywordtype">void</span> bar_set_bar( BarClass *bc, <span class="keywordtype">int</span> val ) { bc-&gt;bar = val;  }
</pre></div><p>
And here's the methods for <code>FooClass:</code> <p>
 <div class="fragment"><pre class="fragment"><span class="comment">// FooClass allocator </span>
FooClass *foo_new( <span class="keywordtype">int</span> foo, <span class="keywordtype">int</span> bar )
{
    FooClass *fc;

    fc = <a class="code" href="avrmalloc_8c.html#a543f348351cdcaebdd8947d1a591578" title="Macro for allocating memory.">avr_new</a>( FooClass, 1 );
    foo_construct( fc, foo, bar );
    <a class="code" href="avrclass_8c.html#82d397ff00a7f1c1447832dbff1856e1" title="Overload the default destroy method.">class_overload_destroy</a>( (AvrClass *)fc, foo_destroy );

    <span class="keywordflow">return</span> fc;
}

<span class="comment">// FooClass constructor </span>
<span class="keywordtype">void</span> foo_construct( FooClass *fc, <span class="keywordtype">int</span> foo, bar )
{
    bar_construct( (BarClass *)fc, bar );
    fc-&gt;foo = foo;
}

<span class="comment">// FooClass destructor </span>
<span class="keywordtype">void</span> foo_destroy( <span class="keywordtype">void</span> *fc )
{
    <span class="keywordflow">if</span> (fc == NULL)
        <span class="keywordflow">return</span>;

    <a class="code" href="avrclass_8c.html#86e290a528dd1ed0bf5057056b5731e5" title="Releases resources allocated by class&amp;#39;s &amp;lt;klass&amp;gt;_new() function.">class_destroy</a>( fc );
}

<span class="comment">// FooClass public data access methods </span>

<span class="keywordtype">int</span>  foo_get_foo( FooClass *fc )          { <span class="keywordflow">return</span> fc-&gt;foo; }
<span class="keywordtype">void</span> foo_set_foo( FooClass *fc, <span class="keywordtype">int</span> val ) { fc-&gt;foo = val;  }

<span class="keywordtype">int</span>  foo_get_bar( FooClass *fc )
{
    <span class="keywordflow">return</span> bar_get_bar( (BarClass *)fc );
}

<span class="keywordtype">void</span> foo_set_bar( FooClass *fc, <span class="keywordtype">int</span> val )
{
    bar_set_bar( (BarClass *)fc, val );
}
</pre></div><p>
Take a good look at the <code>*_new</code>(), <code>*_construct</code>() and <code>*_destroy</code>() functions in the above examples and make sure you understand what's going on. Of particluar importance is how the constructor and destructor functions are chained up along the various classes. This pattern is used extensively throughout the simulavr source code and once understood, makes some complicated concepts incredibly easy to implement.<p>
Now that we have the method functions, we can rewrite our original example function without the broken encapsulation.<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> func( <span class="keywordtype">void</span> )
{
    <span class="keywordtype">int</span> num;
    FooClass *Foo = foo_new( 12, 21 );

    num = foo_get_foo( Foo );
    num = foo_get_bar( Foo );

    <a class="code" href="avrclass_8c.html#0e597261f2fe0c7c5a56de97ecc38693" title="Decrements the reference count for the klass object.">class_unref</a>( (AvrClass *)Foo );
}
</pre></div><p>
Now that's better, but you might think that we are breaking encapsulation when we cast <code>Foo</code> to <code>AvrClass</code>. Well, in a way we are, but since <em>all</em> class objects <em>must</em> be derived from <code>AvrClass</code> either directly or indirectly, this is acceptable.<h2><a class="anchor" name="object_refencing">
Object Referencing</a></h2>
<p>
You may have noticed by this point that we haven't called <a class="el" href="avrmalloc_8c.html#082a9d6d40f5e8bad64441ad950ec12c" title="Free malloc&#39;d memory.">avr_free()</a> to free the memory we allocated for our objects. We called <a class="el" href="avrclass_8c.html#0e597261f2fe0c7c5a56de97ecc38693" title="Decrements the reference count for the klass object.">class_unref()</a> instead. This mechanism allows us to store many references to a single object without having to keep track of all of them.<p>
The only thing we must do when we store a reference to an object in a new variable, is call <a class="el" href="avrclass_8c.html#ff0f5b14bf2740f208041d515f3ba93f" title="Increments the reference count for the klass object.">class_ref()</a> on the object. Then, when that stored reference is no longer needed, we simply call <a class="el" href="avrclass_8c.html#0e597261f2fe0c7c5a56de97ecc38693" title="Decrements the reference count for the klass object.">class_unref()</a> on the object. Once the reference count reaches zero, the object's destroy method is automatically called for us. The only hard part for us is knowing when to ref and unref the object.<p>
Here's an example from the simulavr code for callbacks:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> callback_construct( CallBack *cb,
                         CallBack_FP func,
                         AvrClass *data )
{
    <span class="keywordflow">if</span> (cb == NULL)
        <a class="code" href="avrerror_8c.html#4f6ec50114a7d63093baecafe47d7f1a" title="Print an error message to stderr and terminate program.">avr_error</a>( <span class="stringliteral">"passed null ptr"</span>);

    <a class="code" href="avrclass_8c.html#ffeb66dd49a62ad1b7606cde0e3b039e" title="Initializes the AvrClass data structure.">class_construct</a>( (AvrClass *)cb );

    cb-&gt;func = func;

    cb-&gt;data = data;
    <a class="code" href="avrclass_8c.html#ff0f5b14bf2740f208041d515f3ba93f" title="Increments the reference count for the klass object.">class_ref</a>( data );
}

<span class="keywordtype">void</span> callback_destroy( <span class="keywordtype">void</span> *cb )
{
    CallBack *_cb = (CallBack *)cb;

    <span class="keywordflow">if</span> (cb == NULL)
        <span class="keywordflow">return</span>;

    <a class="code" href="avrclass_8c.html#0e597261f2fe0c7c5a56de97ecc38693" title="Decrements the reference count for the klass object.">class_unref</a>( _cb-&gt;data );

    <a class="code" href="avrclass_8c.html#86e290a528dd1ed0bf5057056b5731e5" title="Releases resources allocated by class&amp;#39;s &amp;lt;klass&amp;gt;_new() function.">class_destroy</a>( cb );
}
</pre></div><p>
Notice that <code>data</code> is a pointer to <code>AvrClass</code> and thus can be any class defined by simulavr. <code>CallBack</code> is another class which happens to store a reference to <code>data</code> and must therefore call <a class="el" href="avrclass_8c.html#ff0f5b14bf2740f208041d515f3ba93f" title="Increments the reference count for the klass object.">class_ref()</a> on the <code>data</code> object. When the callback is destroyed (because the reference count reached zero), the callback destroy method calls <a class="el" href="avrclass_8c.html#0e597261f2fe0c7c5a56de97ecc38693" title="Decrements the reference count for the klass object.">class_unref()</a> on the <code>data</code> object. It is assumed that the original reference to <code>data</code> still exists when the callback is created, but may or may not exist when the callback is destroyed. </div>

<hr width="80%">
<p><center>Automatically generated by Doxygen 1.5.5 on 7 Nov 2008.</center></p>

</body>
</html>
